---
title: "Project1"
format: html
editor: visual
---

## Data Processing

### First Steps - Read in one section of the data.

**1. Read in the data and select only few columns as required.**

```{r}
library(tidyverse)
data <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
data <- data |>
  select(Area_name, STCOU, ends_with("D")) |>
  rename(area_name=Area_name)
data
```

**2. Convert the data into long format where each row has only one enrollment value for that Area_name.**

```{r}
library(tidyr)
data <- data |>
  pivot_longer(cols=3:12,
               names_to = "label",
               values_to = "enrollment_value")
data
```

**3. Parse the "label" string**\
For the "label" column, the first three characters represent the survey with the next four representing the type of value you have from that survey. The last two digits prior to the “D” represent the year of the measurement.

-   Parse the "label" string to pull out the year and convert the year into a numeric value such as 1997 or 2002.
-   Grab the first three characters and following four digits to create a new variable representing which measurement was grabbed.

```{r}
#create a function to convert two-digit character to four-digit numeric year.
convert_year <- function(year) {
  year <- as.numeric(year)
  ifelse(year > 24, 1900 + year, 2000 + year)
}

data <- data |>
  # parse the "label" string
  mutate(year=substr(label, 8, 9)) |>
  mutate(year=convert_year(year)) |>
  # grab measurement information
  mutate(measurement = substr(label, 1, 7))
data

```

**4. Create two data sets**

-   one data set that contains only non-county data
-   one data set that contains only county level data

```{r}
data_noncounty <- data [-grep(pattern = ", \\w\\w", data$area_name),]
data_noncounty
data_county <- data [grep(pattern = ", \\w\\w", data$area_name),]
data_county
```

-   For the county level data, add a class to the tibble called county.
-   Similarly, add a class to the non-county data called state.

```{r}
class(data_county) <- c("county", class(data_county))
class(data_county)
class(data_noncounty) <- c("state", class(data_noncounty))
class(data_noncounty)
```

**5. For the county level tibble, create a new variable that describes which state one of these county measurements corresponds to.**

```{r}
data_county <- data_county |>
  mutate(state = substr(area_name, nchar(area_name)-1, nchar(area_name)))
data_county
```

**6. For the non-county level tibble, create a new variable called “division” corresponding to the state’s classification of division here. If row corresponds to a non-state (i.e. UNITED STATES), return ERROR for the division. The code for this part will not be a ton of fun but can be made easier with the use of %in%.**

```{r}
# define the state’s classification of division
Northeast <- c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", 
               "NEW JERSEY", "NEW YORK", "PENNSYLVANIA", "RHODE ISLAND",
               "VERMONT")
Midwest <- c("ILLINOIS", "INDIANA", "IOWA", "KANSAS", "MICHIGAN", 
             "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA",
             "OHIO", "SOUTH DAKOTA", "WISCONSIN")
South <- c("ALABAMA", "ARKANSAS", "DELAWARE", "DISTRICT OF COLUMBIA",
           "FLORIDA", "GEORGIA", "KENTUCKY", "LOUISIANA", "MARYLAND",
           "MISSISSIPPI", "NORTH CAROLINA", "OKLAHOMA", "SOUTH CAROLINA",
           "TENNESSEE", "TEXAS", "VIRGINIA", "WEST VIRGINIA")
West <- c("ALASKA", "ARIZONA", "CALIFORNIA", "COLORADO", "HAWAII", "IDAHO",
          "MONTANA", "NEVADA", "NEW MEXICO", "OREGON", "UTAH", "WASHINGTON",
          "WYOMING")

data_noncounty <- data_noncounty |>
  # convert area_name to upper case
  mutate(area_name = toupper(area_name)) |>
  # classify the states
  mutate(division = ifelse(area_name == "UNITED STATES", "ERROR", 
                           ifelse (area_name %in% Northeast,
                                   "Northeast", 
                                   ifelse(area_name %in% Midwest,
                                          "Midwest", 
                                          ifelse(area_name %in% South,
                                                 "South",
                                                 ifelse(area_name %in% West, 
                                                        "West", 
                                                        "CHECK"))))))
data_noncounty
```


**Now we want to repeat the above process for the 2nd component of the data set.**

```{r}
data2 <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")

#Crate a function for steps 1 and 2
function_for_step_1_2 <- function(data2, value_col_name = "enrollment_value") {
  data2 <- data2 |>
    select(Area_name, STCOU, ends_with("D")) |>
    rename(area_name = Area_name) |>
    pivot_longer(cols = 3:12, 
                 names_to = "label", 
                 values_to = value_col_name)
  return(data2)
}

#Process data
data2 <- function_for_step_1_2(data2)

#Crate a function for step 3
function_for_step_3 <- function(data2) {
  data2 <- data2 %>%
    mutate(year = as.numeric(substr(label, 8, 9)),
           year = ifelse(year > 24, 1900 + year, 2000 + year),
           measurement = substr(label, 1, 7))
  return(data2)
}

data2 <- function_for_step_3(data2)

function_for_step_5 <- function(data_county2) {
  data_county2 <- data_county2 %>%
    mutate(state = substr(area_name, nchar(area_name) - 1, nchar(area_name)))
  return(data_county2)
}

#Crate a function for step 6
function_for_step_6 <- function(data_noncounty2) {
  Northeast <- c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", 
                 "NEW JERSEY", "NEW YORK", "PENNSYLVANIA", "RHODE ISLAND",
                 "VERMONT")
  Midwest <- c("ILLINOIS", "INDIANA", "IOWA", "KANSAS", "MICHIGAN", 
               "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA",
               "OHIO", "SOUTH DAKOTA", "WISCONSIN")
  South <- c("ALABAMA", "ARKANSAS", "DELAWARE", "DISTRICT OF COLUMBIA",
             "FLORIDA", "GEORGIA", "KENTUCKY", "LOUISIANA", "MARYLAND",
             "MISSISSIPPI", "NORTH CAROLINA", "OKLAHOMA", "SOUTH CAROLINA",
             "TENNESSEE", "TEXAS", "VIRGINIA", "WEST VIRGINIA")
  West <- c("ALASKA", "ARIZONA", "CALIFORNIA", "COLORADO", "HAWAII", "IDAHO",
            "MONTANA", "NEVADA", "NEW MEXICO", "OREGON", "UTAH", "WASHINGTON",
            "WYOMING")
  
  data_noncounty2 <- data_noncounty2 %>%
    mutate(area_name = toupper(area_name),
           division = case_when(
             area_name == "UNITED STATES" ~ "ERROR",
             area_name %in% Northeast ~ "Northeast",
             area_name %in% Midwest ~ "Midwest",
             area_name %in% South ~ "South",
             area_name %in% West ~ "West",
             TRUE ~ "CHECK"
           ))
  return(data_noncounty2)
}

#Crate a function for final step
function_for_steps4_5_6 <- function(data2) {
  data_noncounty2 <- data2[-grep(pattern = ", \\w\\w", data2$area_name), ]
  data_county2 <- data2[grep(pattern = ", \\w\\w", data2$area_name), ]
  
  class(data_noncounty2) <- c("state", class(data_noncounty2))
  class(data_county2) <- c("county", class(data_county2))
  
  data_county2 <- function_for_step_5(data_county2)
  data_noncounty2 <- function_for_step_6(data_noncounty2)
  
  return(list(noncounty2 = data_noncounty2, county2 = data_county2))
}

#Process data
results <- function_for_steps4_5_6(data2)
data2_noncounty <- results$noncounty
data2_county <- results$county
```

**Creating wrapper function**

```{r}
# Define wrapper function
my_wrapper <- function(url, default_var_name = "enrollment_value") {
  data <- read_csv(url)
  
  # Function for steps 1 and 2
  data <- data %>%
    select(Area_name, STCOU, ends_with("D")) %>%
    rename(area_name = Area_name) %>%
    pivot_longer(cols = 3:12, names_to = "label", values_to = default_var_name)
  
  # Function for step 3
  data <- data %>%
    mutate(year = as.numeric(substr(label, 8, 9)),
           year = ifelse(year > 24, 1900 + year, 2000 + year),
           measurement = substr(label, 1, 7))
  
  # Function for steps 4, 5, and 6
  function_for_steps4_5_6 <- function(data2) {
    data_noncounty2 <- data2[-grep(pattern = ", \\w\\w", data2$area_name), ]
    data_county2 <- data2[grep(pattern = ", \\w\\w", data2$area_name), ]
    
    class(data_noncounty2) <- c("state", class(data_noncounty2))
    class(data_county2) <- c("county", class(data_county2))
    
    data_county2 <- function_for_step_5(data_county2)
    data_noncounty2 <- function_for_step_6(data_noncounty2)
    
    return(list(noncounty2 = data_noncounty2, county2 = data_county2))
  }
  
  # Process data
  results <- function_for_steps4_5_6(data)
  data_noncounty <- results$noncounty2
  data_county <- results$county2
  
  # Return the results
  return(list(noncounty = data_noncounty, county = data_county))
}

# Example usage:
url <- "https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv"
results <- my_wrapper(url)

# Access non-county and county data
data_noncounty3 <- results$noncounty
data_county3 <- results$county
```


**Call it and combine your data**

```{r}
# URLs for the two CSV files
url1 <- "https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv"
url2 <- "https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv"  

# Call the wrapper function for the first dataset
results1 <- my_wrapper(url1, default_var_name = "enrollment_value")

# Process data
data1_noncounty <- results1$noncounty
data1_county <- results1$county

# Call the wrapper function for the second dataset
results2 <- my_wrapper(url2, default_var_name = "enrollment_value")

# Process data
data2_noncounty <- results2$noncounty
data2_county <- results2$county

```


**Single short function**
```{r}
#Creat combined short function
combine <- function(results1, results2) {
  combined_county <- bind_rows(results1$county, results2$county)
  combined_noncounty <- bind_rows(results1$noncounty, results2$noncounty)
  return(list(county = combined_county, noncounty = combined_noncounty))
}

#Process data
combined_results <- combine(results1, results2)
combined_county <- combined_results$county
combined_noncounty <- combined_results$noncounty
```

